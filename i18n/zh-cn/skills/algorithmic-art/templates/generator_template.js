/**
 * ═══════════════════════════════════════════════════════════════════════════
 *                  P5.JS 生成艺术 - 最佳实践
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * 本文件展示了 p5.js 生成艺术的结构和原则。
 * 它并不规定你应该创建什么样的艺术。
 *
 * 你的算法哲学应该指导你构建什么。
 * 这些只是如何组织代码的最佳实践。
 *
 * ═══════════════════════════════════════════════════════════════════════════
 */

// ============================================================================
// 1. 参数组织
// ============================================================================
// 将所有可调节的参数放在一个对象中
// 这样做可以轻松地：
// - 连接到 UI 控件
// - 重置为默认值
// - 序列化/保存配置

let params = {
    // 定义与你的算法匹配的参数
    // 示例（根据你的艺术定制）：
    // - 计数：元素数量（粒子、圆圈、分支等）
    // - 缩放：大小、速度、间距
    // - 概率：事件发生的可能性
    // - 角度：旋转、方向
    // - 颜色：调色板数组

    seed: 12345,
    // 将 colorPalette 定义为数组 -- 选择你喜欢的颜色 ['#d97757', '#6a9bcc', '#788c5d', '#b0aea5']
    // 根据你的算法添加你的参数
};

// ============================================================================
// 2. 种子随机性（可重复性的关键）
// ============================================================================
// 始终对 Art Blocks 风格的可重复输出使用种子随机

function initializeSeed(seed) {
    randomSeed(seed);
    noiseSeed(seed);
    // 现在所有的 random() 和 noise() 调用都将具有确定性
}

// ============================================================================
// 3. P5.JS 生命周期
// ============================================================================

function setup() {
    createCanvas(800, 800);

    // 首先初始化种子
    initializeSeed(params.seed);

    // 设置你的生成系统
    // 这里是你初始化的地方：
    // - 对象数组
    // - 网格结构
    // - 初始位置
    // - 起始状态

    // 对于静态艺术：在 setup 结尾调用 noLoop()
    // 对于动态艺术：让 draw() 继续运行
}

function draw() {
    // 选项 1：静态生成（运行一次，然后停止）
    // - 在 setup() 中生成所有内容
    // - 在 setup() 中调用 noLoop()
    // - draw() 做得不多或可以为空

    // 选项 2：动态生成（连续）
    // - 每帧更新你的系统
    // - 常见模式：粒子运动、生长、进化
    // - 可选地在 N 帧后调用 noLoop()

    // 选项 3：用户触发的重新生成
    // - 默认使用 noLoop()
    // - 当参数改变时调用 redraw()
}

// ============================================================================
// 4. 类结构（当你需要对象时）
// ============================================================================
// 当你的算法涉及多个实体时使用类
// 示例：粒子、代理、细胞、节点等

class Entity {
    constructor() {
        // 初始化实体属性
        // 这里使用 random() - 它将被播种
    }

    update() {
        // 更新实体状态
        // 这可能涉及：
        // - 物理计算
        // - 行为规则
        // - 与邻居的交互
    }

    display() {
        // 渲染实体
        // 将渲染逻辑与更新逻辑分开
    }
}

// ============================================================================
// 5. 性能考虑
// ============================================================================

// 对于大量元素：
// - 尽可能预先计算
// - 使用简单的碰撞检测（如需要，使用空间哈希）
// - 当可能时限制昂贵的操作（sqrt、三角函数）
// - 考虑高效使用 p5 向量

// 为了流畅的动画：
// - 目标 60fps
// - 如果运行缓慢，进行性能分析
// - 考虑减少粒子数量或简化计算

// ============================================================================
// 6. 实用函数
// ============================================================================

// 颜色实用工具
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

function colorFromPalette(index) {
    return params.colorPalette[index % params.colorPalette.length];
}

// 映射和缓动
function mapRange(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
}

function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// 约束到边界
function wrapAround(value, max) {
    if (value < 0) return max;
    if (value > max) return 0;
    return value;
}

// ============================================================================
// 7. 参数更新（连接到 UI）
// ============================================================================

function updateParameter(paramName, value) {
    params[paramName] = value;
    // 决定是否需要重新生成或只是更新
    // 一些参数可以实时更新，其他参数需要完全重新生成
}

function regenerate() {
    // 重新初始化你的生成系统
    // 当参数显著变化时很有用
    initializeSeed(params.seed);
    // 然后重新生成你的系统
}

// ============================================================================
// 8. 常见的 P5.JS 模式
// ============================================================================

// 使用透明度进行轨迹/淡出效果
function fadeBackground(opacity) {
    fill(250, 249, 245, opacity); // 带透明度的 Anthropic 浅色
    noStroke();
    rect(0, 0, width, height);
}

// 使用噪声进行有机变化
function getNoiseValue(x, y, scale = 0.01) {
    return noise(x * scale, y * scale);
}

// 从角度创建向量
function vectorFromAngle(angle, magnitude = 1) {
    return createVector(cos(angle), sin(angle)).mult(magnitude);
}

// ============================================================================
// 9. 导出函数
// ============================================================================

function exportImage() {
    saveCanvas('generative-art-' + params.seed, 'png');
}

// ============================================================================
// 记住
// ============================================================================
//
// 这些是工具和原则，不是食谱。
// 你的算法哲学应该指导你创建什么。
// 这种结构帮助你很好地创建它！
//
// 专注于：
// - 干净、易读的代码
// - 参数化以进行探索
// - 播种以实现可重复性
// - 高性能执行
//
// 艺术本身完全取决于你！
//
// ============================================================================